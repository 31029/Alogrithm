## Ⅰ. 程序 = 算法 + 数据结构 （此乃目的也）

### 一、通用技巧：

#### **`解题通用思路方面`**

- 每一道题 在审题时 **都当做完全独立的普通题型**，**先用常规思维思考，再确定特定解题方法**
- 仔细审题后，**之后一定要先在脑海中先确定好大致可行的解题思路，再开始码题**。
  - 技巧：条条大路通罗马，**可以先用能想到的最快速的方法先解决问题**，完成问题后再考虑优化方案，但是这并不意味着你就不需要去了解更优秀的方法。（甚至可以考虑暴力法但不推荐）
- 注意题目中的**隐藏条件**。      
  - 示例：【`哈希表-7`】




#### **`编码方面`**

- 具体做题时，**先考虑最通常的情况**，最后再使用 `if语句` **处理特殊情况**。（不过能一起处理最好一起处理）

- 开始一个**`循环`**前，请先根据题意思考以下方面：

  - 确定**循环区间以及循环区间边界**处的意义，`[a, b]` or `[a, b)`?  （小技巧：前者循环b-a+1次，而后者循环b-a次。）
  - 循环的终止条件所代表的含义。
  - 区间的定义就是不变量，那么在循环中坚持根据查找区间的定义来做边界处理，就是循环不变量规则。
  - **嵌套循环**：**父循环的大条件在子循环中不要忘记加上**（**`哈希表-8、9（三、四数之和）`**）。

- **碰到稍微难一点的题目时**，一时想不出思路，可以从以下几个技巧**寻找突破口**：
  - **暴力法时间复杂度不能接受时**，就**猜一个时间复杂度**，然后基于这个时间复杂度去推断可能的思路。（空间换时间）
  - 有时候按思路下去多写几个for循环，虽然看上去很傻，但是能提供一些思路。   
    -   【`数组-5，哈希表-7（四数相加）`】
  
- **Tricks**:
  - **剪枝**
  - forr 一个map或者slice时，注意 k和v的取值的命名最好清晰易懂 （拓展：**`所有变量名命名都应该清晰易懂`**！）



### 二、一些心得

- 要明白 算法的特殊地位，写算法题时要有一种发自内心的尊重感。
- 每周做完题之后，记得复盘 + 总结笔记。（可以按照工作日：两天三道题这样的节奏来推进。）
- **做算法题积累自信很重要！**







## Ⅱ. 分题型

### 一、链表

- 1、`删除链表的头节点和删除其他节点的操作不一致`，要特别注意。

- 2、大多数情况下可以设置一个 **`虚拟头节点`**，可以简化思路和代码。

  - ```
    dummy := &ListNode{
            	Next: head,
       		 }
    
    pre := dummy
    ```


- 3、用 **`LinkNode指针数组`** **`将链表问题转化为数组问题`**有时候解题很方便（空间换时间）
  - link_node 章节第4,5,6题均采用此法，一次通过~
  - 一般不推荐，偶尔想表现或者实在没办法再用这个方法。
- 4、做链表题时牢记 go语言中 **`指针 和 指针存储地址 的区别`**，即可在编码时保持清醒不会混乱。
- 5、解决链表问题常常涉及到 **`双指针`** 题型的解决办法。





### 二、哈希表

- 1、很多时候哈希表类型的题目并不会从题干中明显提示需要用哈希表来解答，即**hash表是一种特殊方法，在解一些特定题型时十分有效**。

- 2、这些 **`特定题型的特征 `**有：

  - 首先我再强调一下 **什么时候使用哈希法**，当我们需要**查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。（`以空间换时间`）**
  - 使用hash表时需要理清楚的思路：
  - <img src="F:\Work_Project\2024\Picgo\image-20241007121000183.png" alt="image-20241007121000183" style="zoom:67%;" />

- 3、针对 哈希表 题目的一些常用优化思路：

  - 能不能用一张Hash表解决题目问题？（涉及到同时对同一张哈希表采用不同操作思路）
  - make(map， len) 时规定长度，避免动态扩容的时间和空间浪费。

  
  
  

### 三、字符串

- 熟练 go 字符串实现，以及字符串切片操作。

- [Golang 单引号、双引号和反引号_golang ``-CSDN博客](https://blog.csdn.net/iotisan/article/details/104687737?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~PaidSort-1-104687737-blog-137878813.235^v43^pc_blog_bottom_relevance_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~PaidSort-1-104687737-blog-137878813.235^v43^pc_blog_bottom_relevance_base2&utm_relevant_index=2)
  - []byte 数组要比较字符是否相等直接： byte[a] == 'a'



### 四、栈和队列

- 1、除非特定题目要求实现栈和队列外，其余题目要掌握**通过列表或数组快速实现栈和队列的能力**。
- 2、看到 “**按顺序**”，“**先进后出**” 等关键字，要考虑使用栈或者队列





### 五、双指针

- 当快/慢（左/右）指针重合时的特殊情况处理，一定要想清楚。





### 六、二叉树

- 整个二叉树章节除了少数特定题型外（涉及迭代、层序遍历的题型），绝大部分题型的解题核心即：**`递归！`**
- **`递归技巧:`**
  - **步骤**：![image-20240909205957217](https://raw.githubusercontent.com/31029/PicGo/main/image-20240909205957217.png)
  - 递归时涉及到左、右子树分别递归时，**可以先完成一边的逻辑编写，另外一边稍作更改即可套用！**



### 七、回溯

**1、定义**

​	**1️⃣ 什么是回溯**

- **有递归就有回溯**
- 可以**先思考一下暴力法的解法，再分析如何用回溯去写**，因为**回溯本质上也是一种暴力搜索，但是其避免了 例如大量for循环嵌套的问题。**



​	**2️⃣  回溯模板**

![image-20241207113503488](https://raw.githubusercontent.com/31029/PicGo/main/image-20241207113503488.png)





**2、技巧**

**1️⃣  通用**

- 为了**避免递归函数参数过多**，可以声明部分参数为**全局变量**。



**2️⃣  画图法**

![image-20241218153403561](https://raw.githubusercontent.com/31029/PicGo/main/image-20241218153403561.png)

​	在大脑中模拟回溯过搜索的过程是很困难的，**所以需要通过抽象后的图形结构来进一步理解回溯**  
​	之前说过回溯法解决的问题都可以抽象为**树形结构（N 叉树）**。**用树性结构来理解回溯就容易多了**





### 八、贪心算法

**1、定义**

**1️⃣ 什么是贪心**

- **贪心的本质就是选择每一阶段的局部最优，从而实现全局最优。**
- 那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？**最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧**。

**2️⃣ 贪心模板**

贪心算法一般分为如下四步：

- **将问题分解为若干个子问题**
- **找出适合的贪心策略**
- **求解每一个子问题的最优解**
- **将局部最优解堆叠成全局最优解**

这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。

做题的时候，**只要想清楚 局部最优 是什么，如果推导出全局最优**，其实就够了。





### 九、动态规划

**1、定义**

**1️⃣ 什么是动态规划**

- 如果某一问题有很多**重叠子问题**，使用动态规划是最有效的。所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的。

- 大家知道**动规是由前一个状态推导出来的**，而**贪心是局部直接选最优的，**对于刷题来说就够用了。

  - 例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

    动态规划中**dp[j]**是由**dp[j-weight[i]]**推导出来的，然后取**max(dp[j], dp[j - weight[i]] + value[i])**。

**2️⃣ 动规模板**

**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**

（1）确定**dp数组（dp table）**以及  **下标的含义**

（2）确定  **递推公式**

（3）dp数组  **如何初始化**

（4）确定  **遍历顺序**

（5）**举例推导dp数组**



**2、技巧**

**1️⃣  调试**

- 找问题的最好方式就是**把dp数组打印**出来，看看究竟是不是按照自己思路推导的！

- 做动规的题目，写代码之前一定要把**状态转移在dp数组**的上**具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。**





### 十、图论

- 正是因为BFS一圈一圈的遍历方式，所以一旦遇到终止点，那么一定是一条最短路径。
- 深搜模板：

**![image-20241216112945163](https://raw.githubusercontent.com/31029/PicGo/main/image-20241216112945163.png)**

- 广搜模板：

```c++
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向
// grid 是地图，也就是一个二维数组
// visited标记访问过的节点，不要重复访问
// x,y 表示开始搜索节点的下标
void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
    queue<pair<int, int>> que; // 定义队列
    que.push({x, y}); // 起始节点加入队列
    visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点
    while(!que.empty()) { // 开始遍历队列里的元素
        pair<int ,int> cur = que.front(); que.pop(); // 从队列取元素
        int curx = cur.first;
        int cury = cur.second; // 当前节点坐标
        for (int i = 0; i < 4; i++) { // 开始想当前节点的四个方向左右上下去遍历
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 坐标越界了，直接跳过
            if (!visited[nextx][nexty]) { // 如果节点没被访问过
                que.push({nextx, nexty});  // 队列添加该节点为下一轮要遍历的节点
                visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问
            }
        }
    }

}
```

