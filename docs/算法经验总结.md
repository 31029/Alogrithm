## Ⅰ. 程序 = 算法 + 数据结构 （此乃目的也）

### 一、通用技巧：

#### **`解题通用思路方面`**

- 每一道题 在审题时 **都当做完全独立的普通题型**，**先用常规思维思考，再确定特定解题方法**
- 仔细审题后，**之后一定要先在脑海中先确定好大致可行的解题思路，再开始码题**。
  - 技巧：条条大路通罗马，**可以先用能想到的最快速的方法先解决问题**，完成问题后再考虑优化方案，但是这并不意味着你就不需要去了解更优秀的方法。（甚至可以考虑暴力法但不推荐）
- 注意题目中的**隐藏条件**。      
  - 示例：【`哈希表-7`】




#### **`编码方面`**

- 具体做题时，**先考虑最通常的情况**，最后再使用 `if语句` **处理特殊情况**。（不过能一起处理最好一起处理）

- 开始一个**`循环`**前，请先根据题意思考以下方面：

  - 确定**循环区间以及循环区间边界**处的意义，`[a, b]` or `[a, b)`?  （小技巧：前者循环b-a+1次，而后者循环b-a次。）
  - 循环的终止条件所代表的含义。
  - 区间的定义就是不变量，那么在循环中坚持根据查找区间的定义来做边界处理，就是循环不变量规则。
  - **嵌套循环**：**父循环的大条件在子循环中不要忘记加上**（**`哈希表-8、9（三、四数之和）`**）。

- **碰到稍微难一点的题目时**，一时想不出思路，可以从以下几个技巧**寻找突破口**：
  - **暴力法时间复杂度不能接受时**，就**猜一个时间复杂度**，然后基于这个时间复杂度去推断可能的思路。（空间换时间）
  - 有时候按思路下去多写几个for循环，虽然看上去很傻，但是能提供一些思路。   
    -   【`数组-5，哈希表-7（四数相加）`】
  
- **Tricks**:
  - **剪枝**
  - forr 一个map或者slice时，注意 k和v的取值的命名最好清晰易懂 （拓展：**`所有变量名命名都应该清晰易懂`**！）



### 二、一些心得

- 要明白 算法的特殊地位，写算法题时要有一种发自内心的尊重感。
- 每周做完题之后，记得复盘 + 总结笔记。（可以按照工作日：两天三道题这样的节奏来推进。）
- **做算法题积累自信很重要！**







## Ⅱ. 分题型

### 一、链表

- 1、`删除链表的头节点和删除其他节点的操作不一致`，要特别注意。

- 2、大多数情况下可以设置一个 **`虚拟头节点`**，可以简化思路和代码。

  - ```
    dummy := &ListNode{
            	Next: head,
       		 }
    
    pre := dummy
    ```


- 3、用 **`LinkNode指针数组`** **`将链表问题转化为数组问题`**有时候解题很方便（空间换时间）
  - link_node 章节第4,5,6题均采用此法，一次通过~
  - 一般不推荐，偶尔想表现或者实在没办法再用这个方法。
- 4、做链表题时牢记 go语言中 **`指针 和 指针存储地址 的区别`**，即可在编码时保持清醒不会混乱。
- 5、解决链表问题常常涉及到 **`双指针`** 题型的解决办法。





### 二、哈希表

- 1、很多时候哈希表类型的题目并不会从题干中明显提示需要用哈希表来解答，即**hash表是一种特殊方法，在解一些特定题型时十分有效**。

- 2、这些 **`特定题型的特征 `**有：

  - 首先我再强调一下 **什么时候使用哈希法**，当我们需要**查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。（`以空间换时间`）**
  - 使用hash表时需要理清楚的思路：
  - <img src="F:\Work_Project\2024\Picgo\image-20241007121000183.png" alt="image-20241007121000183" style="zoom:67%;" />

- 3、针对 哈希表 题目的一些常用优化思路：

  - 能不能用一张Hash表解决题目问题？（涉及到同时对同一张哈希表采用不同操作思路）
  - make(map， len) 时规定长度，避免动态扩容的时间和空间浪费。

  
  
  

### 三、字符串

- 熟练 go 字符串实现，以及字符串切片操作。

- [Golang 单引号、双引号和反引号_golang ``-CSDN博客](https://blog.csdn.net/iotisan/article/details/104687737?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~PaidSort-1-104687737-blog-137878813.235^v43^pc_blog_bottom_relevance_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~PaidSort-1-104687737-blog-137878813.235^v43^pc_blog_bottom_relevance_base2&utm_relevant_index=2)
  - []byte 数组要比较字符是否相等直接： byte[a] == 'a'



### 四、栈和队列

- 1、除非特定题目要求实现栈和队列外，其余题目要掌握**通过列表或数组快速实现栈和队列的能力**。
- 2、看到 “**按顺序**”，“**先进后出**” 等关键字，要考虑使用栈或者队列





### 五、双指针

- 当快/慢（左/右）指针重合时的特殊情况处理，一定要想清楚。





### 六、二叉树

- 整个二叉树章节除了少数特定题型外（涉及迭代、层序遍历的题型），绝大部分题型的解题核心即：**`递归！`**
- **`递归技巧:`**
  - **步骤**：![image-20240909205957217](https://raw.githubusercontent.com/31029/PicGo/main/image-20240909205957217.png)
  - 递归时涉及到左、右子树分别递归时，**可以先完成一边的逻辑编写，另外一边稍作更改即可套用！**



### 七、回溯

#### 1、定义

##### 1️⃣ 什么是回溯

- 有递归就有回溯

##### 2️⃣  回溯模板

![image-20241207113503488](https://raw.githubusercontent.com/31029/PicGo/main/image-20241207113503488.png)



#### 2、技巧

##### 1️⃣  通用

- 可以**先思考一下暴力法的解法，再分析如何用回溯去写**，因为**回溯本质上也是一种暴力搜索，但是其避免了 例如大量for循环嵌套的问题。**
- 为了**避免递归函数参数过多**，可以声明部分参数为**全局变量**。

##### 2️⃣  画图法

​	在大脑中模拟回溯过搜索的过程是很困难的，**所以需要通过抽象后的图形结构来进一步理解回溯**  
​	之前说过回溯法解决的问题都可以抽象为**树形结构（N 叉树）**。**用树性结构来理解回溯就容易多了**



### 八、贪心算法

#### 1、定义

##### 1️⃣ 什么是贪心

- 贪心的本质就是选择每一阶段的局部最优，从而实现全局最优。
- 那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？**最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧**。

##### 2️⃣ 贪心模板

贪心算法一般分为如下四步：

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。

做题的时候，**只要想清楚 局部最优 是什么，如果推导出全局最优**，其实就够了。
